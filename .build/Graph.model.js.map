{
  "version": 3,
  "sources": ["../Graph.model.ts"],
  "sourcesContent": ["import { log } from \"console\"\nimport Apex from \"./Apex.model\"\nimport Edge from \"./Edge.model\"\n\ninterface ApexInfo {\n  degree: number,\n  exit: number,\n  input: number,\n  apex: Apex\n}\n\nexport default class {\n  public apexes: Apex[] = []\n  public edges: Edge[] = []\n  public is_oriented: boolean\n\n  constructor(is_oriented: number, quantity_of_apex: number) {\n    this.is_oriented = is_oriented == 1\n    for (let i = 1; i <= quantity_of_apex; i++) {\n      this.apexes.push(new Apex(i));\n    }\n  }\n\n  public listInfoApexes(): Array<ApexInfo> {\n    let response: Array<ApexInfo> = []\n    this.apexes.forEach(apex => {\n      let input = 0\n      let exit = 0\n      let degree = 0\n\n      this.edges.forEach(edge => {\n        exit += edge.from === apex ? 1 : 0\n        input += edge.to === apex ? 1 : 0\n      })\n      degree = input + exit\n\n      response.push({\n        degree: degree,\n        input: input,\n        exit: exit,\n        apex: apex\n      })\n\n    })\n    return response\n  }\n\n  public createEdge(index: number, from: number, to: number): void {\n    this.edges.push(new Edge(\n      index,\n      this.apexes.find(apex => apex.index === from),\n      this.apexes.find(apex => apex.index === to)\n    ))\n  }\n\n  public generateMatrix(heigth: number, width: number): Array<Array<Number>> {\n    const matrix: Array<Array<Number>> = [];\n    for (let i = 0; i <= heigth; i++) {\n      matrix.push([])\n      for (let j = 0; j <= width; j++) {\n        matrix[i].push(0)\n      }\n    }\n\n    for(let i = 1; i <= heigth; i++){\n      matrix[i][0] = i \n    }\n    for(let j = 1; j <= width; j++){\n      matrix[0][j] = j\n    }\n\n\n    return matrix\n  } \n   \n\n  public generateMatrixIncidents(): Array<Array<Number>> {\n    const matrix: Array<Array<Number>> = this.generateMatrix(this.apexes.length, this.edges.length);\n    this.edges.forEach(edge => {\n      matrix[edge.from.index][edge.index] =\n        this.is_oriented ? -1 : 1\n      matrix[edge.to.index][edge.index] = 1\n    })\n\n    return matrix\n  }\n\n  public generateMatrixContiguity(): Array<Array<Number>> {\n    const matrix: Array<Array<Number>> = this.generateMatrix(this.apexes.length, this.apexes.length);\n\n    this.edges.forEach(edge => {\n      matrix[edge.from.index][edge.to.index] = 1\n      this.is_oriented ?\n        matrix[edge.to.index][edge.from.index] = 1 : []\n\n    })\n\n    return matrix\n  }\n\n\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AACA,kBAAiB;AACjB,kBAAiB;AASjB,0BAAqB;AAAA,EACZ,SAAiB;AAAA,EACjB,QAAgB;AAAA,EAChB;AAAA,EAEP,YAAY,aAAqB,kBAA0B;AACzD,SAAK,cAAc,eAAe;AAClC,aAAS,IAAI,GAAG,KAAK,kBAAkB,KAAK;AAC1C,WAAK,OAAO,KAAK,IAAI,oBAAK;AAAA;AAAA;AAAA,EAIvB,iBAAkC;AACvC,QAAI,WAA4B;AAChC,SAAK,OAAO,QAAQ,UAAQ;AAC1B,UAAI,QAAQ;AACZ,UAAI,OAAO;AACX,UAAI,SAAS;AAEb,WAAK,MAAM,QAAQ,UAAQ;AACzB,gBAAQ,KAAK,SAAS,OAAO,IAAI;AACjC,iBAAS,KAAK,OAAO,OAAO,IAAI;AAAA;AAElC,eAAS,QAAQ;AAEjB,eAAS,KAAK;AAAA,QACZ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA;AAIJ,WAAO;AAAA;AAAA,EAGF,WAAW,OAAe,MAAc,IAAkB;AAC/D,SAAK,MAAM,KAAK,IAAI,oBAClB,OACA,KAAK,OAAO,KAAK,UAAQ,KAAK,UAAU,OACxC,KAAK,OAAO,KAAK,UAAQ,KAAK,UAAU;AAAA;AAAA,EAIrC,eAAe,QAAgB,OAAqC;AACzE,UAAM,SAA+B;AACrC,aAAS,IAAI,GAAG,KAAK,QAAQ,KAAK;AAChC,aAAO,KAAK;AACZ,eAAS,IAAI,GAAG,KAAK,OAAO,KAAK;AAC/B,eAAO,GAAG,KAAK;AAAA;AAAA;AAInB,aAAQ,IAAI,GAAG,KAAK,QAAQ,KAAI;AAC9B,aAAO,GAAG,KAAK;AAAA;AAEjB,aAAQ,IAAI,GAAG,KAAK,OAAO,KAAI;AAC7B,aAAO,GAAG,KAAK;AAAA;AAIjB,WAAO;AAAA;AAAA,EAIF,0BAAgD;AACrD,UAAM,SAA+B,KAAK,eAAe,KAAK,OAAO,QAAQ,KAAK,MAAM;AACxF,SAAK,MAAM,QAAQ,UAAQ;AACzB,aAAO,KAAK,KAAK,OAAO,KAAK,SAC3B,KAAK,cAAc,KAAK;AAC1B,aAAO,KAAK,GAAG,OAAO,KAAK,SAAS;AAAA;AAGtC,WAAO;AAAA;AAAA,EAGF,2BAAiD;AACtD,UAAM,SAA+B,KAAK,eAAe,KAAK,OAAO,QAAQ,KAAK,OAAO;AAEzF,SAAK,MAAM,QAAQ,UAAQ;AACzB,aAAO,KAAK,KAAK,OAAO,KAAK,GAAG,SAAS;AACzC,WAAK,cACH,OAAO,KAAK,GAAG,OAAO,KAAK,KAAK,SAAS,IAAI;AAAA;AAIjD,WAAO;AAAA;AAAA;",
  "names": []
}
