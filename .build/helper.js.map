{
  "version": 3,
  "sources": ["../helper.ts"],
  "sourcesContent": ["import { log } from \"console\" \nimport reader from 'readline-sync'\nimport Graph from \"./models/Graph.model\"\nconst writeTwoDementionalArray = (array: number[][], \n                                  name: string = 'Array', \n                                  addHeader: boolean = true): void => {\n\n  \n                                    \n  log(`\\n \\n`)\n  log(`-----------${name}---------- \\n \\n`)\n  if(addHeader){\n    array.length > 1 ? array[0].length : array.length \n    let line = ''\n    for(let i = 0; i <= (array.length > 1 ? array[0].length : array.length) ; i++){\n      line += `${i}   `\n    }\n    log(`${line} \\n`) \n  }\n  array.forEach((arr, index) => {\n    let line = addHeader ? `${index + 1}   ` : ''\n    arr.forEach(el => {\n      line += `${el}   `\n    })\n    log(`${line} \\n`) \n  })\n\n       log(`-------------${'end'}-------------- \\n`)                             \n}\n\n\nconst question = (question: string, validor: Function = () => true, show_invalid: boolean = true) => {\n  let repeat = true;\n  let invalid_input = false\n  let response = ''\n\n  while (repeat) {\n    repeat = false\n\n    const full_question = (invalid_input && show_invalid ? 'Invalid input, please ' : '') + question\n    const input = reader.question(full_question)\n\n    !validor(input) ? [repeat = true, invalid_input = true] : response = input\n\n  }\n\n  return response\n}\n\nconst readGraph = (defaultOriented: any = null) => {\n  const graph = new Graph(\n    defaultOriented === null ? Number(\n      question('Graph is oriented (1 || 0)? \\n', (e: string) => {\n        return Number(e) === 1 || Number(e) === 0\n      })\n    ) : defaultOriented,\n    Number(\n      question('Enter quantity of apexes (n > 0)? \\n', (e: string) => Number(e) > 0)\n    )\n  )\n  \n  const graph_max_apex = graph.apexes.length\n  // log(graph)\n  \n  log('Now input edge\\'s apexes, to stop write \"end\" \\n')\n  \n  let index = 1\n  while (true) {\n    const input = question\n      (`New edge\\'s start from ~ to, example: (1 2),\n        n (${'1' + ' ~ ' + String(graph_max_apex)}) apex: ? \\n`,\n        (e: string) => {\n          if (e === 'end') {\n            return true\n          }\n          e.includes(' ') ? [] : false\n          const from = e.split(' ')[0]\n          const to = e.split(' ')[1]\n          return Number(from) > 0 && Number(from) <= graph_max_apex &&\n            Number(to) > 0 && Number(to) <= graph_max_apex\n  \n        })\n  \n    if (input === 'end') {\n      break\n    }\n  \n    const from = Number(input.split(' ')[0])\n    const to = Number(input.split(' ')[1])\n  \n    graph.createEdge(index, from, to)\n  \n    index += 1\n  \n  }\n\n  return graph\n}\n\n\nfunction boolMainDiagonal(matrix: number[][], bool: boolean): number[][] {\n    // Get number of rows and columns in matrix\n    const n = matrix.length;\n\n    // Set main diagonal elements to 0\n    for (let i = 0; i < n; i++) {\n        matrix[i][i] = Number(bool);\n    }\n    \n    return matrix\n}\n\nfunction bfs(start: number, graph: number[][]): number[] {\n  // Initialize a queue and a distances array\n  const queue = [start];\n  const distances = new Array(graph.length).fill(Infinity);\n  // Mark the start node as being at distance 0\n  distances[start] = 0;\n\n  // While there are nodes in the queue\n  while (queue.length > 0) {\n    // Dequeue the first node in the queue\n    const current = queue.shift();\n    // For each of its neighbors\n    for (const neighbor of graph[current]) {\n      // If we haven't visited the neighbor yet\n      if (distances[neighbor] === Infinity) {\n        // Mark the neighbor as visited and enqueue it\n        distances[neighbor] = distances[current] + 1;\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  return distances;\n}\n\nfunction dfs(currentVertex: number, startVertex: number, visited: boolean[], stack: Stack<number>, adjacencyMatrix: number[][]): boolean {\n  // Mark the current vertex as visited\n  visited[currentVertex] = true;\n  stack.push(currentVertex);\n\n  // Iterate through all the neighbors of the current vertex\n  for (let neighbor = 0; neighbor < adjacencyMatrix[currentVertex].length; neighbor++) {\n    // Check if the neighbor is connected to the current vertex\n    if (adjacencyMatrix[currentVertex][neighbor] === 1) {\n      // Check if the neighbor is the start vertex (forming a cycle)\n      if (neighbor === startVertex) {\n        // A cycle was found, so return true\n        return true;\n      }\n      // Check if the neighbor has not been visited\n      if (!visited[neighbor]) {\n        // Perform a depth-first search from the neighbor\n        if (dfs(neighbor, startVertex, visited, stack, adjacencyMatrix)) {\n          // A cycle was found, so return true\n          return true;\n        }\n      }\n    }\n  }\n\n  // No cycle was found, so remove the current vertex from the stack and return false\n  stack.pop();\n  return false;\n}\n\nexport {\n  writeTwoDementionalArray, question, readGraph, boolMainDiagonal, bfs, dfs\n}"],
  "mappings": "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",
  "names": []
}
