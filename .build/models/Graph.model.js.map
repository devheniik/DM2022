{
  "version": 3,
  "sources": ["../../models/Graph.model.ts"],
  "sourcesContent": ["import Apex from \"./Apex.model\"\nimport Edge from \"./Edge.model\"\nimport { Stack } from 'typescript-collections'\nimport {boolMainDiagonal, bfs} from \"../helper\"\nimport { log } from \"console\"\n\ninterface ApexInfo {\n  degree: number,\n  exit: number,\n  input: number,\n  apex: Apex\n}\n\nexport default class {\n  public apexes: Apex[] = []\n  public edges: Edge[] = []\n  public is_oriented: boolean\n\n  constructor(is_oriented: number, quantity_of_apex: number) {\n    this.is_oriented = is_oriented == 1\n    for (let i = 1; i <= quantity_of_apex; i++) {\n      this.apexes.push(new Apex(i));\n    }\n  }\n\n  public listInfoApexes(): Array<ApexInfo> {\n    let response: Array<ApexInfo> = []\n    this.apexes.forEach(apex => {\n      let input = 0\n      let exit = 0\n      let degree = 0\n\n      this.edges.forEach(edge => {\n        exit += edge.from === apex ? 1 : 0\n        input += edge.to === apex ? 1 : 0\n      })\n      degree = input + exit\n\n      response.push({\n        degree: degree,\n        input: input,\n        exit: exit,\n        apex: apex\n      })\n\n    })\n    return response\n  }\n\n  public createEdge(index: number, from: number, to: number): void {\n    this.edges.push(new Edge(\n      index,\n      this.apexes.find(apex => apex.index === from),\n      this.apexes.find(apex => apex.index === to)\n    ))\n  }\n\n  public generateMatrix(heigth: number, width: number): number[][] {\n    const matrix: number[][] = [];\n    for (let i = 0; i < heigth; i++) {\n      matrix.push([])\n      for (let j = 0; j < width; j++) {\n        matrix[i].push(0)\n      }\n    }\n\n    // for(let i = 1; i <= heigth; i++){\n    //   matrix[i][0] = i \n    // }\n    // for(let j = 1; j <= width; j++){\n    //   matrix[0][j] = j\n    // }\n\n\n    return matrix\n  } \n   \n\n  public generateMatrixIncidents(): number[][] {\n    const matrix: number[][] = this.generateMatrix(this.apexes.length, this.edges.length);\n    this.edges.forEach(edge => {\n      matrix[edge.from.index - 1][edge.index - 1] =\n        this.is_oriented ? -1 : 1\n      matrix[edge.to.index - 1][edge.index - 1] = 1\n    })\n\n    return matrix\n  }\n\n  public generateMatrixContiguity(): number[][] {\n    const matrix: number[][] = this.generateMatrix(this.apexes.length, this.apexes.length);\n\n    this.edges.forEach(edge => {\n      matrix[edge.from.index - 1][edge.to.index - 1] = 1\n      !this.is_oriented ?\n        matrix[edge.to.index - 1][edge.from.index - 1] = 1 : []\n\n    })\n\n    return matrix\n  } \n\n  public  getDistanceMatrix(graph: number[][] = this.getEdgesArray(), apexes_quantity: number = this.apexes.length): number[][] {\n  // Initialize the distance matrix with Infinity values\n    // log(graph, graph.length)\n  let distanceMatrix: number[][] = [];\n  for (let i = 0; i < apexes_quantity; i++) {\n    distanceMatrix[i] = [];\n    for (let j = 0; j < apexes_quantity; j++) {\n      distanceMatrix[i][j] = Infinity;\n    }\n  }\n\n  // Set the distance between each node to 1\n  for (const [u, v] of graph) {\n    distanceMatrix[u - 1][v - 1] = 1;\n    distanceMatrix[v - 1][u - 1] = 1;\n  }\n\n  distanceMatrix = boolMainDiagonal(distanceMatrix, 0);\n\n  // Apply the Floyd-Warshall algorithm to calculate the distances between all pairs of nodes\n  for (let k = 0; k < apexes_quantity; k++) {\n    for (let i = 0; i < apexes_quantity; i++) {\n      for (let j = 0; j < apexes_quantity; j++) {\n        distanceMatrix[i][j] = Math.min(distanceMatrix[i][j], distanceMatrix[i][k] + distanceMatrix[k][j]);\n      }\n    }\n  }\n\n  return distanceMatrix;\n}\n\n  private getEdgesArray(): number[][]{\n    \n    return this.edges.map(e => [ e.from.index, e.to.index ])\n  }\n\n  public getReachabilityMatrix(graph: number[][] = this.getEdgesArray(), apexes_quantity: number = this.apexes.length): number[][] {\n  // Initialize the reachability matrix with 0 values\n  const reachabilityMatrix: number[][] = [];\n  for (let i = 0; i < apexes_quantity; i++) {\n    reachabilityMatrix[i] = [];\n    for (let j = 0; j < apexes_quantity; j++) {\n      reachabilityMatrix[i][j] = 0;\n    }\n  }\n\n  // Set the reachability between each node to 1\n  for (const [u, v] of graph) {\n    reachabilityMatrix[u - 1][v - 1] = 1;\n    reachabilityMatrix[v - 1][u - 1] = 1;\n  }\n\n  // Apply the Floyd-Warshall algorithm to calculate the reachability between all pairs of nodes\n  for (let k = 0; k < apexes_quantity; k++) {\n    for (let i = 0; i < apexes_quantity; i++) {\n      for (let j = 0; j < apexes_quantity; j++) {\n        reachabilityMatrix[i][j] = reachabilityMatrix[i][j] || (reachabilityMatrix[i][k] && reachabilityMatrix[k][j]);\n      }\n    }\n  }\n\n  return reachabilityMatrix;\n}\n\n  public getDistance(): number{\n    const matrix: number [][] = this.getDistanceMatrix()\n    let maxValue = -1;\n    matrix.forEach(row => {\n      row.forEach(n => {\n        maxValue < n ? maxValue = n : []\n      })\n    })  \n\n  \n\n    return maxValue\n  }\n\n  public findRadius(graph: number[][] = this.getEdgesArray()): number {\n  // Find the maximum distance from any node to all other nodes\n    const matrix: number [][] = this.getDistanceMatrix()\n    let maxes: number[] = [];\n    matrix.forEach(row => { \n      maxes.push(Math.max(...row))\n    })  \n\n    return Math.min(...maxes)\n  }\n  \n  \n  public findCentres(graph: number[][] = this.getEdgesArray()): number[] {\n  // Find the maximum distance from any node to all other nodes\n    const matrix: number [][] = this.getDistanceMatrix()\n    const radius: number = this.findRadius()\n    let centres: number[] = [];\n    matrix.forEach((row, index) => { \n      Math.max(...row) == radius ? centres.push(index + 1) : []\n    })  \n\n    return centres\n  }\n\n  \n  \n  public findTiers(graph: number[][] = this.getEdgesArray()): Tier[] {\n  // Find the maximum distance from any node to all other nodes\n    const matrix: number [][] = this.getDistanceMatrix()\n    const radius: number = this.findRadius()\n    let tiers: Tier[] = []\n    matrix.forEach((row, index) => { \n      tiers.push({\n        index: index + 1,\n        value: Math.max(...row) - radius\n      }) \n    })  \n\n    return tiers\n  }\n\n   public findSimpleCycles(adjMatrix: number[][] = this.generateMatrixContiguity(), vertexAmount: number = this.apexes.length): number[][] {\n    const simpleCycles: number[][] = [];\n  \n    function dfs(node: number, visited: boolean[], path: number[]): void {\n      path.push(node);\n      visited[node] = true;\n  \n      for (let i = 1; i < vertexAmount; i++) {\n        if (adjMatrix[node][i] && !visited[i]) {\n          dfs(i, visited, path);\n        } else if (adjMatrix[node][i] && path.includes(i)) {\n          if (!simpleCycles.includes(path.slice(path.indexOf(i))) && path.slice(path.indexOf(i)).length > 2) {\n            simpleCycles.push(path.slice(path.indexOf(i)));\n          }\n        }\n      }\n      \n      path.pop();\n    }\n  \n    const visited: boolean[] = new Array(vertexAmount).fill(false);\n    for (let i = 1; i < vertexAmount; i++) {\n      dfs(i, visited, []);\n    }\n\n    log(simpleCycles.map(cycle => cycle.map(x => x + 1)))\n    return simpleCycles.map(cycle => cycle.map(x => x + 1));\n  }\n  \n}\n\ninterface Tier {\n  index: number,\n  value: number\n}"],
  "mappings": "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",
  "names": []
}
